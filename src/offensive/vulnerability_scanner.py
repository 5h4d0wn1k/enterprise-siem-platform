"""
Enterprise SIEM Platform - Vulnerability Scanner

This module provides integration with external vulnerability scanning tools
and supports simulated vulnerability scans for testing.
"""
import time
import logging
import queue
import threading
import random
import json
import os
import re
import subprocess
import requests
from typing import List, Dict, Optional, Tuple, Any
from datetime import datetime, timedelta

from src.utils.event import Event

class ScanResult:
    """Represents a vulnerability scan result."""
    
    SEVERITY_MAP = {
        "critical": 4,
        "high": 3,
        "medium": 2,
        "low": 1,
        "info": 0
    }
    
    def __init__(self, 
                 target: str,
                 vulnerability_id: str,
                 name: str,
                 description: str,
                 severity: str,
                 cvss_score: Optional[float] = None,
                 cve_ids: Optional[List[str]] = None,
                 affected_component: Optional[str] = None,
                 remediation: Optional[str] = None,
                 scan_id: Optional[str] = None,
                 timestamp: Optional[float] = None,
                 details: Optional[Dict] = None):
        """Initialize a scan result.
        
        Args:
            target: Target IP or hostname
            vulnerability_id: ID of the vulnerability 
            name: Name/title of the vulnerability
            description: Description of the vulnerability
            severity: Severity level (critical, high, medium, low, info)
            cvss_score: Optional CVSS score (0.0-10.0)
            cve_ids: Optional list of CVE IDs
            affected_component: Optional affected component or service
            remediation: Optional remediation steps
            scan_id: Optional ID of the scan that found this result
            timestamp: Optional timestamp of when the vulnerability was found
            details: Additional details about the vulnerability
        """
        self.target = target
        self.vulnerability_id = vulnerability_id
        self.name = name
        self.description = description
        self.severity = severity.lower()
        self.cvss_score = cvss_score
        self.cve_ids = cve_ids or []
        self.affected_component = affected_component
        self.remediation = remediation
        self.scan_id = scan_id
        self.timestamp = timestamp or time.time()
        self.details = details or {}
        
    def get_severity_level(self) -> int:
        """Get numeric severity level.
        
        Returns:
            Integer severity level (0-4)
        """
        return self.SEVERITY_MAP.get(self.severity, 0)
        
    def to_dict(self) -> Dict:
        """Convert to dictionary.
        
        Returns:
            Dictionary representation
        """
        return {
            'target': self.target,
            'vulnerability_id': self.vulnerability_id,
            'name': self.name,
            'description': self.description,
            'severity': self.severity,
            'cvss_score': self.cvss_score,
            'cve_ids': self.cve_ids,
            'affected_component': self.affected_component,
            'remediation': self.remediation,
            'scan_id': self.scan_id,
            'timestamp': self.timestamp,
            'details': self.details
        }
        
    @classmethod
    def from_dict(cls, data: Dict) -> 'ScanResult':
        """Create from dictionary.
        
        Args:
            data: Dictionary with scan result data
            
        Returns:
            ScanResult object
        """
        return cls(
            target=data.get('target', ''),
            vulnerability_id=data.get('vulnerability_id', ''),
            name=data.get('name', ''),
            description=data.get('description', ''),
            severity=data.get('severity', 'info'),
            cvss_score=data.get('cvss_score'),
            cve_ids=data.get('cve_ids', []),
            affected_component=data.get('affected_component'),
            remediation=data.get('remediation'),
            scan_id=data.get('scan_id'),
            timestamp=data.get('timestamp', time.time()),
            details=data.get('details', {})
        )


class VulnerabilityScanner:
    """Integrates with vulnerability scanning tools and provides simulation."""
    
    def __init__(self, config: dict):
        """Initialize the vulnerability scanner.
        
        Args:
            config: Dictionary with scanner configuration
        """
        self.config = config
        self.enabled = config.get('enabled', False)
        self.scan_interval = config.get('scan_interval', 86400)  # Default: daily scans
        self.scanner_type = config.get('scanner_type', 'simulate')  # simulate, openvas, nessus
        
        # OpenVAS configuration
        self.openvas_config = config.get('openvas', {})
        self.openvas_host = self.openvas_config.get('host', 'localhost')
        self.openvas_port = self.openvas_config.get('port', 9390)
        self.openvas_username = self.openvas_config.get('username', '')
        self.openvas_password = self.openvas_config.get('password', '')
        
        # Nessus configuration
        self.nessus_config = config.get('nessus', {})
        self.nessus_url = self.nessus_config.get('url', 'https://localhost:8834')
        self.nessus_access_key = self.nessus_config.get('access_key', '')
        self.nessus_secret_key = self.nessus_config.get('secret_key', '')
        
        # Simulation configuration
        self.simulate_config = config.get('simulate', {})
        self.simulate_targets = self.simulate_config.get('targets', [])
        self.simulate_num_findings = self.simulate_config.get('num_findings', (5, 15))  # Min, max range
        self.simulate_severity_distribution = self.simulate_config.get('severity_distribution', {
            'critical': 0.05,  # 5% critical findings
            'high': 0.15,      # 15% high findings
            'medium': 0.30,    # 30% medium findings
            'low': 0.40,       # 40% low findings
            'info': 0.10       # 10% informational findings
        })
        
        # Common vulnerabilities for simulation
        self.common_web_vulnerabilities = [
            {
                'name': 'SQL Injection',
                'description': 'SQL injection vulnerability in the application allows an attacker to execute arbitrary SQL commands.',
                'remediation': 'Use parameterized queries or prepared statements. Validate and sanitize user input.',
                'cve_examples': ['CVE-2020-12345', 'CVE-2021-67890'],
                'affected_component': 'Web Application',
                'severity': 'critical',
                'cvss_range': (7.5, 10.0)
            },
            {
                'name': 'Cross-Site Scripting (XSS)',
                'description': 'Cross-site scripting vulnerability allows attackers to inject malicious scripts into web pages viewed by users.',
                'remediation': 'Implement proper output encoding. Use Content Security Policy (CSP).',
                'cve_examples': ['CVE-2021-12345', 'CVE-2020-45678'],
                'affected_component': 'Web Application',
                'severity': 'high',
                'cvss_range': (6.0, 8.5)
            },
            {
                'name': 'Cross-Site Request Forgery (CSRF)',
                'description': 'Application is vulnerable to CSRF which allows attackers to perform actions on behalf of authenticated users.',
                'remediation': 'Implement anti-CSRF tokens. Use SameSite cookie attribute.',
                'cve_examples': ['CVE-2019-98765', 'CVE-2020-54321'],
                'affected_component': 'Web Application',
                'severity': 'medium',
                'cvss_range': (4.0, 6.5)
            },
            {
                'name': 'Insecure Direct Object References',
                'description': 'Application exposes internal implementation objects to users without proper access control.',
                'remediation': 'Implement proper access controls. Use indirect references.',
                'cve_examples': ['CVE-2018-12345', 'CVE-2019-23456'],
                'affected_component': 'Web Application',
                'severity': 'high',
                'cvss_range': (5.5, 7.5)
            }
        ]
        
        self.common_network_vulnerabilities = [
            {
                'name': 'Outdated SSL/TLS',
                'description': 'Server supports outdated SSL/TLS protocols that are susceptible to known attacks.',
                'remediation': 'Disable support for SSLv2, SSLv3, TLS 1.0, and TLS 1.1. Enable only TLS 1.2 and TLS 1.3.',
                'cve_examples': ['CVE-2014-3566', 'CVE-2016-0800'],
                'affected_component': 'Web Server',
                'severity': 'medium',
                'cvss_range': (4.3, 5.9)
            },
            {
                'name': 'Open SMB Ports',
                'description': 'Server has SMB ports open that could be exploited for unauthorized access or information disclosure.',
                'remediation': 'If not needed, disable SMB ports (139, 445). Otherwise, ensure SMB is properly configured and updated.',
                'cve_examples': ['CVE-2017-0144', 'CVE-2020-0796'],
                'affected_component': 'File Sharing',
                'severity': 'high',
                'cvss_range': (7.0, 9.3)
            },
            {
                'name': 'Default SNMP Community Strings',
                'description': 'SNMP service is configured with default or weak community strings, allowing unauthorized access.',
                'remediation': 'Change default community strings. Use SNMPv3 with authentication and encryption.',
                'cve_examples': [],
                'affected_component': 'SNMP Service',
                'severity': 'medium',
                'cvss_range': (5.0, 6.5)
            },
            {
                'name': 'SSH Weak Algorithms',
                'description': 'SSH server supports weak cryptographic algorithms that can be exploited.',
                'remediation': 'Disable weak ciphers, MACs, and key exchange algorithms in SSH configuration.',
                'cve_examples': ['CVE-2016-0778'],
                'affected_component': 'SSH Server',
                'severity': 'medium',
                'cvss_range': (4.0, 5.5)
            }
        ]
        
        self.common_system_vulnerabilities = [
            {
                'name': 'Outdated Operating System',
                'description': 'The operating system is outdated and missing security patches for known vulnerabilities.',
                'remediation': 'Apply latest security updates and patches. Consider upgrading to a supported OS version.',
                'cve_examples': [],
                'affected_component': 'Operating System',
                'severity': 'high',
                'cvss_range': (7.0, 8.5)
            },
            {
                'name': 'Unpatched Software',
                'description': 'Software running on the system has known vulnerabilities that have not been patched.',
                'remediation': 'Update software to the latest version with security patches.',
                'cve_examples': [],
                'affected_component': 'Application Software',
                'severity': 'high',
                'cvss_range': (6.5, 8.0)
            },
            {
                'name': 'Unnecessary Services Running',
                'description': 'Unnecessary services or daemons are running on the system, increasing the attack surface.',
                'remediation': 'Disable or remove unnecessary services. Implement the principle of least functionality.',
                'cve_examples': [],
                'affected_component': 'System Services',
                'severity': 'low',
                'cvss_range': (2.0, 3.5)
            },
            {
                'name': 'Weak Password Policy',
                'description': 'System uses weak password policies that allow simple passwords or long expiration times.',
                'remediation': 'Implement stronger password policies including complexity, length, and expiration requirements.',
                'cve_examples': [],
                'affected_component': 'Authentication',
                'severity': 'medium',
                'cvss_range': (4.0, 5.5)
            }
        ]
        
        # Track scan results
        self.last_scan_results = {}  # target -> list of ScanResult objects
        self.last_scan_time = 0
        
        self.logger = logging.getLogger(__name__)
        
    def run_simulate_scan(self) -> List[ScanResult]:
        """Run a simulated vulnerability scan.
        
        Returns:
            List of ScanResult objects
        """
        if not self.simulate_targets:
            self.logger.warning("No targets configured for simulation")
            return []
            
        results = []
        scan_id = f"SIM-{int(time.time())}"
        
        for target in self.simulate_targets:
            # Determine how many findings to generate
            min_findings, max_findings = self.simulate_num_findings
            num_findings = random.randint(min_findings, max_findings)
            
            # Generate findings based on severity distribution
            findings_by_severity = {}
            for severity, percentage in self.simulate_severity_distribution.items():
                findings_by_severity[severity] = int(num_findings * percentage)
            
            # Ensure we have at least the minimum number by adding any rounding errors to 'low' category
            total_allocated = sum(findings_by_severity.values())
            if total_allocated < num_findings:
                findings_by_severity['low'] += (num_findings - total_allocated)
            
            # Generate findings for each severity
            for severity, count in findings_by_severity.items():
                for _ in range(count):
                    # Pick vulnerability template based on severity and randomize elements
                    templates = []
                    for vuln_list in [self.common_web_vulnerabilities, self.common_network_vulnerabilities, self.common_system_vulnerabilities]:
                        templates.extend([v for v in vuln_list if v['severity'] == severity])
                    
                    if not templates:
                        # Fallback if no template for this severity
                        templates = self.common_web_vulnerabilities + self.common_network_vulnerabilities + self.common_system_vulnerabilities
                    
                    template = random.choice(templates)
                    
                    # Generate random CVSS score within range
                    min_cvss, max_cvss = template.get('cvss_range', (0.0, 10.0))
                    cvss_score = round(random.uniform(min_cvss, max_cvss), 1)
                    
                    # Pick a random CVE if available in template
                    cve_ids = []
                    if template.get('cve_examples') and random.random() < 0.7:  # 70% chance to include CVE
                        cve_ids = [random.choice(template['cve_examples'])]
                    
                    # Create scan result
                    result = ScanResult(
                        target=target,
                        vulnerability_id=f"VUL-{int(time.time())}-{random.randint(1000, 9999)}",
                        name=template['name'],
                        description=template['description'],
                        severity=severity,
                        cvss_score=cvss_score,
                        cve_ids=cve_ids,
                        affected_component=template['affected_component'],
                        remediation=template['remediation'],
                        scan_id=scan_id,
                        timestamp=time.time(),
                        details={
                            'simulated': True,
                            'port': random.choice([80, 443, 22, 21, 25, 3389, 8080]) if 'Web' not in template['affected_component'] else random.choice([80, 443, 8080, 8443]),
                            'protocol': 'tcp',
                            'path': f"/{random.choice(['login', 'admin', 'user', 'cart', 'profile', 'settings'])}" if 'Web' in template['affected_component'] else '',
                        }
                    )
                    results.append(result)
        
        return results
    
    def run_openvas_scan(self) -> List[ScanResult]:
        """Run an OpenVAS vulnerability scan.
        
        Returns:
            List of ScanResult objects
        """
        self.logger.info("Integration with OpenVAS is not fully implemented")
        self.logger.info("This would connect to OpenVAS using GVM-Tools or the GVM-Python API")
        self.logger.info(f"Would connect to OpenVAS at {self.openvas_host}:{self.openvas_port}")
        
        # In a real implementation, this would:
        # 1. Authenticate with OpenVAS
        # 2. Create a new scan task or get results of an existing one
        # 3. Parse the results into ScanResult objects
        
        # For now, return simulated results
        return self.run_simulate_scan()
    
    def run_nessus_scan(self) -> List[ScanResult]:
        """Run a Nessus vulnerability scan.
        
        Returns:
            List of ScanResult objects
        """
        self.logger.info("Integration with Nessus is not fully implemented")
        self.logger.info("This would connect to Nessus using its REST API")
        self.logger.info(f"Would connect to Nessus at {self.nessus_url}")
        
        # In a real implementation, this would:
        # 1. Authenticate with Nessus API
        # 2. Create a new scan or get results of an existing one
        # 3. Parse the results into ScanResult objects
        
        # For now, return simulated results
        return self.run_simulate_scan()
    
    def compare_scan_results(self, current_results: List[ScanResult]) -> List[Dict]:
        """Compare current scan results with previous scan results.
        
        Args:
            current_results: Current scan results
            
        Returns:
            List of changes detected
        """
        changes = []
        
        # Group current results by target
        current_by_target = {}
        for result in current_results:
            if result.target not in current_by_target:
                current_by_target[result.target] = []
            current_by_target[result.target].append(result)
        
        # Compare with previous results
        for target, results in current_by_target.items():
            # Get previous results for this target
            prev_results = self.last_scan_results.get(target, [])
            
            # Index previous results by vulnerability ID
            prev_by_id = {r.vulnerability_id: r for r in prev_results}
            
            # Check for new or changed vulnerabilities
            for result in results:
                prev_result = prev_by_id.get(result.vulnerability_id)
                
                if prev_result is None:
                    # New vulnerability
                    changes.append({
                        'type': 'new',
                        'target': target,
                        'result': result.to_dict()
                    })
                elif prev_result.severity != result.severity:
                    # Severity changed
                    changes.append({
                        'type': 'changed',
                        'change': 'severity',
                        'target': target,
                        'result': result.to_dict(),
                        'previous': prev_result.to_dict()
                    })
            
            # Check for fixed vulnerabilities
            current_by_id = {r.vulnerability_id: r for r in results}
            for prev_result in prev_results:
                if prev_result.vulnerability_id not in current_by_id:
                    # Vulnerability was fixed
                    changes.append({
                        'type': 'fixed',
                        'target': target,
                        'result': prev_result.to_dict()
                    })
        
        return changes
    
    def generate_events(self, changes: List[Dict]) -> List[Event]:
        """Generate events for vulnerability changes.
        
        Args:
            changes: List of vulnerability changes
            
        Returns:
            List of Event objects
        """
        events = []
        
        for change in changes:
            change_type = change['type']
            target = change['target']
            result = change['result']
            
            # Skip info severity unless it's a fixed vulnerability
            if result['severity'] == 'info' and change_type != 'fixed':
                continue
                
            # Map severity to event severity
            severity_map = {
                'critical': 'critical',
                'high': 'high', 
                'medium': 'medium',
                'low': 'low',
                'info': 'info'
            }
            
            event_severity = severity_map.get(result['severity'], 'medium')
            
            # Generate message based on change type
            if change_type == 'new':
                message = f"New vulnerability found: {result['name']} ({result['severity'].upper()}) on {target}"
                event_type = 'vulnerability_found'
            elif change_type == 'changed':
                previous = change['previous']
                message = f"Vulnerability severity changed: {result['name']} on {target} - {previous['severity'].upper()} to {result['severity'].upper()}"
                event_type = 'vulnerability_changed'
            elif change_type == 'fixed':
                message = f"Vulnerability fixed: {result['name']} ({result['severity'].upper()}) on {target}"
                event_type = 'vulnerability_fixed'
                # Lower severity for fixed vulnerabilities
                event_severity = 'low'
            else:
                continue  # Skip unknown change types
            
            # Create event
            event = Event(
                source='vulnerability_scanner',
                event_type=event_type,
                message=message,
                severity=event_severity,
                details={
                    'target': target,
                    'vulnerability': result,
                    'change_type': change_type,
                    'previous': change.get('previous'),
                    'timestamp': time.time()
                }
            )
            events.append(event)
                
        return events
    
    def run_scanner(self, event_queue: queue.Queue):
        """Run the vulnerability scanner at regular intervals.
        
        Args:
            event_queue: Queue to put events into
        """
        self.logger.info("Vulnerability Scanner starting")
        
        while True:
            try:
                if not self.enabled:
                    time.sleep(60)  # Check every minute if we've been enabled
                    continue
                
                # Check if it's time for a scan
                now = time.time()
                if now - self.last_scan_time < self.scan_interval:
                    remaining = int(self.scan_interval - (now - self.last_scan_time))
                    self.logger.info(f"Next vulnerability scan in {remaining} seconds")
                    time.sleep(min(remaining, 300))  # Sleep for the remaining time or 5 minutes, whichever is less
                    continue
                
                self.logger.info("Starting vulnerability scan")
                scan_start = time.time()
                
                # Run the appropriate scanner
                if self.scanner_type == 'openvas':
                    current_results = self.run_openvas_scan()
                elif self.scanner_type == 'nessus':
                    current_results = self.run_nessus_scan()
                else:
                    current_results = self.run_simulate_scan()
                
                # Compare with previous results
                changes = self.compare_scan_results(current_results)
                
                # Generate events for changes
                events = self.generate_events(changes)
                
                # Put events into queue
                for event in events:
                    event_queue.put(event)
                
                # Update last scan results by target
                for result in current_results:
                    if result.target not in self.last_scan_results:
                        self.last_scan_results[result.target] = []
                    self.last_scan_results[result.target].append(result)
                
                self.last_scan_time = now
                
                scan_duration = time.time() - scan_start
                self.logger.info(f"Vulnerability scan completed in {scan_duration:.2f} seconds. Found {len(current_results)} vulnerabilities with {len(events)} changes.")
                
                # Sleep until next scan
                time.sleep(300)  # Sleep for 5 minutes before checking again
                
            except Exception as e:
                self.logger.error(f"Error in vulnerability scanner: {str(e)}")
                time.sleep(60)  # Wait a minute before retrying